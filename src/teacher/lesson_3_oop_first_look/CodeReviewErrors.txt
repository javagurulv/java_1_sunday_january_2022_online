
WARNING: не нужные комменты в коде

    //constructor without parameters and body
    public Robot(){
    }

Комменты хороши для вас во время учёбы, но в реальном коде
такие "бесполезные" комменты лучше не оставлять.

-----------------------------------------------------------

WARNING: используйте один и тот же стиль форматирования кода
во всех местах.

Robot robot=new Robot();
Robot robot1 = new Robot();

Для читаемости кода лучше знак = окружать пробелами с обеих сторон,
как это сделано во второй строке.

-----------------------------------------------------------

WARNING: не добавляйте и не оставляйте лишние import команды в коде.

import java.sql.SQLOutput;  - что это за класс? Вы его точно используете в коде?
import java.util.Scanner;

Не используемые (лишние) в коде import команды в среде разработки
подсвечиваются серым цветом, их можно смело удалять из кода. Import
команды показывают какие сторонние классы вы используете в своём коде.

-----------------------------------------------------------

WARNING: плохо читаемый код! Без пробелов вся строка сливается
в единое целое и человеку нужно потратить время (пусть и долю секунды)
чтобы разобрать смысл написанного кода.

programmingLanguage==programmingLanguage2

Для читаемости кода лучше знак == окружать пробелами с обеих сторон.

Продуктивность программиста очень сильно зависит от той нагрузки,
с которой он сталкивается при чтении кода. Если код написан плохо,
отформатирован плохо, то программисту читающему ваш код придётся
дополнительно напрягаться, чтобы разобрать смысл. Лишнее напряжение
в одном месте, потом в другом, потом в третьем приводит к быстрой
потере эффективности. Программист это человек, а у человека ресурс
головного мозга и энергии в день очень сильно ограничен. Если
человеку придётся тратить больше времени на прочтение и понимание
вашего кода, то у него останется меньше ресурсов для полезной
деятельности (написания нового кода). Всегда помните, что на
месте читающего код можете оказаться вы сами через месяц или пол года!
Не подставляйте самих себя плохим качеством написанного кода.

-----------------------------------------------------------

WARNING: не объявляйте несколько классов в одном файле
(субъективное мнение).

public class Book {

}

class BookDemo {

}

Да, объявление нескольких классов в одном файле допускается
правилами языка программирования. Но на мой взгляд так лучше
не делать, особенно если мы планируем в будущем писать большие
и серьезные задачи. И вот почему. Класс - это контейнер, в который
мы можем поместить какую то часть функциональности программы. Обычно
мы выделяем часть функциональности тесно связанной друг с другом,
и оформляем (упаковываем) ее в отдельный класс. Тем самым мы
физически отделяем эту часть функциональности от всего остального.
Изолируем ее. И класс (и отдельный файл в котором он лежит) классно
подходят для этой задачи. Помещая несколько классов в один файл
мы, пускай и чуть-чуть, но нарушаем принцип изоляции.
Помещение нескольких классов в один файл имеет смысл на уровне
архитектуры приложения, когда мы хотим сгруппировать в одном месте
несколько реализаций одного и того же интерфейса или класса и не
показывать их за пределы самого файла (если объявить классы как
private, то они будут не доступны даже внутри других классов
этого же пакета).

-----------------------------------------------------------

WARNING: ставьте дополнительные скобки, показывающие
приоритет выполнения операций.

if (number % 2 == 0)
if (firstNumber == secondNumber && firstNumber == thirdNumber)

Лучше: if ((number % 2) == 0)
if ((firstNumber == secondNumber) && (firstNumber == thirdNumber))

Если в одной строке записано выражение состоящее из нескольких
операций, то добавляйте дополнительные скобки, которые покажут
в каком порядке должны выполняться операции. Да, в языке
программирования Java есть понятие приоритета операций.
Но вы о нём помните? Вы уверены на 100%, что операции
в строке будут выполняться именно в том порядке, в котором нужно?
Не заставляйте человека читающего ваш код дополнительно
напрягать свой мозг вспоминая приоритет операций и порядок
их выполнения. Просто расставьте дополнительные скобки!

-----------------------------------------------------------

WARNING: не усложняйте код за счёт лишнего if оператора.

    public boolean isEven(int number) {
        if (number % 2 == 0) {
            return true;
        } else {
            return false;
        }
    }

В данном случае метод возвращает boolean и отвечает на вопрос
чётное число или нет. Проверка чётное число или нет
number % 2 == 0. Так почему же результат этой проверки сразу не
вернуть в качестве результата метода?

Лучше:

    public boolean isEven(int number) {
        return (number % 2) == 0;
    }

-----------------------------------------------------------

WARNING: упрощайте код методов используя приём рефакторинга
вынесения части кода в отдельный метод и его использование повторно.

    public int maxOfThreeNumbers(int firstNumber, int secondNumber, int thirdNumber) {

        if (firstNumber > secondNumber && firstNumber > thirdNumber) {
            return firstNumber;
        } else if (secondNumber > firstNumber && secondNumber > thirdNumber) {
            return secondNumber;
        } else if (firstNumber == secondNumber && firstNumber > thirdNumber) {
            return firstNumber; //or return secondNumber
        } else if (firstNumber == thirdNumber && firstNumber > secondNumber) {
            return firstNumber; //or return  thirdNumber
        } else if (secondNumber == thirdNumber && secondNumber > firstNumber) {
            return secondNumber; // or return thirdNumber
        } else if (firstNumber == secondNumber && secondNumber == thirdNumber) {
            return secondNumber; //return any
        } else {
            return thirdNumber;
        }
    }

Что такое максимальное из трёх чисел? Ответить на такой вопрос в лоб
не просто, надо начинать описывать сложные условия (первое число
больше второго и больше третьего и так далее). Перед нами очевидно
задача, которая требует упрощения! Попробуйте поделить ее на более
мелкие подзадачи. Более простой задачей кажется нахождение
максимального числа из двух. Найдя максимальное из первых двух
и сравнив его с третьим числом мы и найдём максимальное число из трёх.

Лучше:

    public int maxOfTwoNumbers(int firstNumber, int secondNumber) {
        return Math.max(firstNumber, secondNumber);
    }

    public int maxOfThreeNumbers(int firstNumber, int secondNumber, int thirdNumber) {
        int max = maxOfTwoNumbers(firstNumber, secondNumber);
        return maxOfTwoNumbers(max, thirdNumber);
    }

-----------------------------------------------------------

WARNING: давайте названиям тестов названия, которые говорят о том,
что проверяется в тесте.

    public void sumTest()

    public void mulTest()

Лучше:

    public void shouldSumTwoNumbers()

    public void shouldMultiplyTwoNumbers()

-----------------------------------------------------------

WARNING: пример запутанной (сложной) реализации бизнес логики.
Плюс пример не корректной реализации бизнес логики.

class Stock {
    String companyName;
    int currentPrice;
    int minPrice;
    int maxPrice;

    public Stock(String companyName, int currentPrice) {
        this.companyName = companyName;
        this.currentPrice = currentPrice;
        this.minPrice = currentPrice;
        this.maxPrice = currentPrice;
    }

    public void updatePrice(int price) {
        if (maxPrice > currentPrice && minPrice < currentPrice) {
            this.currentPrice = price;
        } else if (price > currentPrice) {
            this.maxPrice = price;
        } else if (price < currentPrice) {
            this.minPrice = price;
        }
    }

Когда будет меняться минимальная или максимальная цена акции?
Просто ли это понять из программного кода? Мне кажется нет.
Проблема этого кода заключается в том, что изменение максимальной
или минимальной цены зависят от первого условия
maxPrice > currentPrice && minPrice < currentPrice, условия,
которое определяет изменение текущей стоимости акции.

А правильно ли меняется текущая цена? Что произойдёт если текущая
цена станет больше чем максимальная? Изменится ли в этом случае
текущая цена?

Проблема этого кода в том, что изменения максимальной, минимальной
и текущей цен зависят друг от друга. Хотя в реальной жизни
определение максимальной, минимальной и текущей цены никак друг
с другом не связаны.

Лучше:

    public void updatePrice(int price) {
        this.currentPrice = price;
        if (price > maxPrice) {
            this.maxPrice = price;
        }
        if (price < minPrice) {
            this.minPrice = price;
        }
    }
